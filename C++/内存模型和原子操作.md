原子操作是不可分割的操作，在一个线程中，原子操作不会处于半完成状态。而非原子操作有可能在完成一半的时候被其他线程所见，C++11引入了原子类型来实现原子操作。
# 标准原子类型
标准原子类型位于头文件<atomic>，这些类型是的操作是原子化的，但是不一定是无锁的，所以它们的成员函数is_lock_free()可以判读是否是无锁操作。而只有atomic_flag没有这个成员，因为它的操作很简单，初始化时清0，通过test_and_set设置，通过clear清空，一定是无锁操作。其余的原子类型都是std::atomic<>特化得到的，比如std::atomic<int>，它还有对应的别名atomic_int，不过我们在编码的时候还是尽量别用别名。
由于不具备拷贝构造函数或拷贝赋值操作符，因此原子类型无法复制和赋值，但是可以接受内建类型赋值，也支持隐式转换成内建类型，也可以交给成员函数处理，如load() store() exchange() comapre_exchange_weak() compare_exchange_strong()。同时还支持运算，如fetch_add() fetch_or()
对于原子类型上的每一种操作，都可以提供额外的参数，从枚举类std::memory_order取值，它有6个可能的值，包括
std::memory_order_relaxed   
std::memory_order_acquire   
std::memory_order_consume   
std::memory_order_acq_rel   
std::memory_order_release   
std::memory_order_seq_cst  
如果没有指定。都会采用最严格的内存次序std::memory_order_seq_cst，我们可以借助原子变量来实现自旋锁。 
# std::atomic_flag实现自旋锁
```C++
class SpinLock {
public:
    SpinLock() = default;
    void Lock() {
        while(flag_.test_and_set(std::memory_order_acquire));
    }
    void Unlock() {
        flag_.clear(std::memory_order_release);
    }
private:
    std::atomic_flag flag_{ATOMIC_FLAG_INIT};
};
```

# 原子操作非成员函数
原子类模板泛化得到的原子类型都具有原子成员函数，其实还有一些非成员函数与其等价。比如std::atomic_load(&var)，std::atomic_store(&var, vale)，std::atomic_store(&var, vale, std::memory_order_release)等，_explicit结尾的是可以指定内存次序的。
借助非成员变量，可以实现多线程对shared_ptr的安全操作，如假设有全局的std::shared_ptr<data> global，多线程访问可以写成，
auto local = std::atomic_load(&p);
auto local = std::make_shard<data>();
std::atomic_store(&p, local);
或者我们也可以用，std::experimental::atomic_shared_ptr

