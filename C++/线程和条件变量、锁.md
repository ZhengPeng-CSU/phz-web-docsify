# C++线程库
thread是c++11新增的线程封装类，本质上和平时看到的一些库里面对pthread的api封装没有区别，需要注意的就是接口的使用。
> # 构造和赋值

默认构造函数thread()
带参构造函数，f是线程体，可以用lambda，后面是参数
thread(f, arg1, arg2…)
构造std::thread对象时，如果不带参则会创建一个空的thread对象，但底层线程并没有真正被创建，一般可将其他std::thread对象通过move移入其中；
如果带参则会创建新线程，而且会被立即运行。
移动后新的所有线程必须判断joinable，否则报错。
```C++
void Func(int a) {
    std::cout << "do nothing" << std::endl;
}

int main() {
    int n = 0;
    std::thread t1; // t1 is not a thread
    std::thread t2(Func, n + 1); // pass by value
    std::thread t3(Func, std::ref(n)); // pass by reference
    std::thread t4(std::move(t3)); // t4 is now running f2(). t3 is no longer a thread
    t2.join();
    t4.join();
}
```
thread构造到线程体传参经过了两层，一是传给构造函数，二才是传给线程函数。
传参中的陷阱：
1、一个实参从主线程传递到子线程的线程函数中，需要经过两次传递。第1次发生在std::thread构造时，此次参数按值并以副本形式被保存,如果要达到按引用传参的效果，可使用std::ref来传递。第2次发生在向线程函数传递时，此次传递是由子线程发起，并将之前std::thread内部保存的副本以右值的形式(std::move())传入线程函数中。
2、如果线程函数的形参为T、const T&或T&&(右值引用)类型时，std::thread的构造函数可以接受左值或右值实参。因为不管是左值还是右值，在std::thread中均是以副本形式被保存，并在第2次向线程函数传参时以右值方式传入，而以上三种形参均可接受右值。
3、而如果线程函数的形参为T&时，不管是左值还是右值的T类型实参，都是无法直接经std::thread传递给形参为T&的线程函数，因为该实参数的副本std::move成右值并传递给线程函数，但T&无法接受右值类型。因此，需要以std::ref形式传入

thread如果要获取线程号，不能通过get_id()，它是thread的id，但不是运行线程的线程id，通常通过static_cast<pid_t>(::syscall(SYS_gettid))的方式获取。
C++20新增了jthread，在析构的时候会自行join。


> # 析构

当thread析构时会判断其是否joinable，则会抛出异常，所以一定不能忘记。同时，需要注意在需要优雅退出的场景下，不推荐长期运行的线程detach，因为分离的线程不结束也进程也是无法正常退出的。  
由于C++目前没有提供终止一个线程的接口，所以我们在join时需要给出线程停止的条件，这点在做优雅退出避免超时时尤为重要。

析构的时候要注意隐藏的死锁，也就是在当前线程等待自己join()，我曾经就碰到过这种场景，简化如下，

```C++
class A;
class B {
public:
    B() {
        std::cout << "construct B" << std::endl;
    }
    ~B() {
        std::cout << "destruct B" << std::endl;
    }
    void Func(std::weak_ptr<A> weak) {
        if (weak.expired()) {
            std::cout << "nullptr" << std::endl;
        }
        auto ptr = weak.lock();
        std::this_thread::sleep_for(2s);
    }
};

class A : public std::enable_shared_from_this<A> {
public:
    A() {
        std::cout << "construct A" << std::endl;
    }
    ~A() {
        std::cout << "destruct A" << std::endl;
        if(trd_.joinable()) {
            trd_.join();
        }
    }
    void TestFunc() {
        trd_ = std::thread([this]() {
            ThreadFunc();
        });
    }

    void ThreadFunc() {
        std::cout << "thread func " << std::endl;
        b.Func(shared_from_this());
        std::this_thread::sleep_for(3s);
    }

private:
    B b;
    std::thread trd_;
};

int main() {
    {
        auto a_ptr = std::make_shared<A>();
        a_ptr->TestFunc();
        std::this_thread::sleep_for(1s);
    }

    std::this_thread::sleep_for(10s);
}
```
执行结果是，deadlock异常。
```bash
construct B
construct A
thread func 
destruct A
terminate called after throwing an instance of 'std::system_error'
  what():  Resource deadlock avoided
已放弃 (核心已转储)
```

还有一点需要注意的是，g++在编译多线程程序的时候应该使用-pthread而不是-lpthread，后者属于过时的写法。

> # 线程退出
std::thread本身没有提供线程退出的接口，一般我们在项目中倾向于用优雅退出的方式，也就是设置退出标志，当需要退出时修改这个标志。然而，有的时候需要调用某个库或者sdk的接口，可能一调用就阻塞了，那么有什么办法退出这个线程呢？可以使用pthread_cancel，这里给出一个例子，
```C++
void Clean(void*) {
    std::cout << "clean up" << std::endl;
}

int main() {
    auto trd_func = []() {
        std::cout << "start thread" << std::endl;
        // 允许取消线程
        pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, nullptr);
        // 立刻取消，PTHREAD_CANCEL_DEFERRED 取消点
        pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, nullptr);
        // 线程取消时运行，注意这是个宏，需要和pthread_cleanup_pop配合使用
        pthread_cleanup_push(Clean, nullptr);

        while(true) {
            pthread_testcancel();
            std::this_thread::sleep_for(10s);
        }
        std::cout << "start thread" << std::endl;
        pthread_cleanup_pop(0);
    };
    std::thread trd(trd_func);
    std::this_thread::sleep_for(10s);
    auto cancel_res = pthread_cancel(trd.native_handle());
    if (cancel_res != 0) {
        std::cout << "cancel error : " << cancel_res << std::endl;
    }
    trd.join();
    std::cout << "main end" << std::endl;
}
```
所谓取消点，是指一些函数调用中会检查取消点，通常是一些系统调用，我一般使用PTHREAD_CANCEL_ASYNCHRONOUS也都可以退出，不过具体业务场景还是需要测试。需要注意的是，调用pthread_cancel(trd.native_handle())时需要确保trd没有detach，否则此时native_handle返回的就是无效的了。

> # 锁
std::mutex

std::lock_guard

std::unique_lock

std::scoped_lock

std::recursive_mutex

std::shared_mutex

C++自旋锁


> # 条件变量

条件变量平时使用的也比较多，记录几个需要注意的点。  
（1）使用wait_for等待时，如果gcc版本小于10.0采用的是system_clock从而受到时间跳变的影响，可能导致等待提前结束或者延长。  
（2）通常我们使用添加变量都要带上一个条件来避免虚假唤醒，wait_for的返回值并不是表示是否超时了，而是结束等待时这个条件的真假。  
```C++
std::mutex test_mutex;
std::condition_variable cv;
bool flag = true;
int main() {
    std::unique_lock lock_test{test_mutex};
    bool res = cv.wait_for(lock_test, 5s, [](){
        return flag;
    });
    std::cout << "res : " << res << std::endl;
}
```
在使用条件变量时，等待方需要先上锁，然后调用条件变量的wait，实际上就是pthrea_cond_wait，wait中再解锁。
那为什么wait前需要加锁呢？
主要还是为了防止条件变化，试想一下A线程准备等待，加入一开始没有加锁，判断等待条件不满足，此时开始等待，但是因为没加锁，调用wait前条件是可能被其他线程改变的。  
你可能会说，不对呀，wait之前判断一下条件不就好了，不满足再wait。但是要知道，判断条件再wait这就是两步动作了，这中间条件还是有可能改变的。所以正确的做法都是加锁，  
再wait，wait后再释放锁，此时能保证条件一致性。
那为什么wait等待满足以后重新加锁呢？
其实还是一样的，也是为了保证条件一致性，防止wait返回后到再次判断前条件发生变化。 
通常notify的线程应该先释放锁再notify，能保证等待者受到信号后无需再等锁。 

> # 基本数据多线程需要加锁吗
之前我在编码的时候认为基本类型只有一个线程写入的时候，另外一个线程读取不需要加锁，比如int或者bool作为判断的flag来用。但是编译器优化可能会导致意外问题，所以应该还是要加锁的，或者用volatile声明，或者直接用原子变量。
```c++
int32_t times = 0;
int32_t total_a = 0;
int32_t total_b = 100;
std::mutex g_mutex;

void Func() {
    std::unique_lock lock{g_mutex};
    int32_t trans = 10;
    total_b -= trans;
    total_a += trans;
    times++;
}

int main() {
    std::cout << "11111111" << std::endl;
    times = 0;
    total_a = 0;
    total_b = 100;
    for (int i = 0; i < 10; i++) {
        std::thread(Func).detach();
    }

    while (true) {
        // std::unique_lock lock{g_mutex};
        if (10 == times) {
            std::cout << "times : " << times << std::endl;
            break;
        }
    }
    std::cout << "times : " << times << std::endl;
    std::this_thread::sleep_for(1s);
    std::cout << "times : " << times << std::endl;
}
```
用02的优化等级编译，上面运行会发现times不等于10，但是if分支依然进去了，指令上看完全不对劲了，这里没搞懂是为什么会优化成这样。之前看别人说的是优化以后导致修改不能读到，进入死循环，但是我这个直接判断就不起作用了。
```bash
0x00000000000013b8 <+168>:   callq  0x12c0 <_ZNSt6thread6detachEv@plt>
0x00000000000013bd <+173>:   cmpq   $0x0,0x8(%rsp)      # while (true)
0x00000000000013c3 <+179>:   jne    0x1498 <main()+392>
0x00000000000013c9 <+185>:   sub    $0x1,%ebx
0x00000000000013cc <+188>:   jne    0x1378 <main()+104>
0x00000000000013ce <+190>:   lea    0x2c6b(%rip),%r12        # 0x4040 <_ZSt4cout@@GLIBCXX_3.4>
0x00000000000013d5 <+197>:   lea    0xc28(%rip),%rsi        # 0x2004
0x00000000000013dc <+204>:   mov    %r12,%rdi
0x00000000000013df <+207>:   callq  0x1230 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
0x00000000000013e4 <+212>:   mov    0x2da2(%rip),%esi        # 0x418c <times>
0x00000000000013ea <+218>:   mov    %rax,%rdi
0x00000000000013ed <+221>:   callq  0x12b0 <_ZNSolsEi@plt>
```
可以看到这里的cmpq直接和立即数0比较，那此时一定是相等的，后面的jne甚至直接跳到main结束了。而且，就算改变了判断条件，比如改成!=，汇编以后得指令还是一样，开起来就像直接认为没有分支了一样。
而如果加了volatile就会发现汇编指令是正常的了，有比较的分支，
```bash
0x00000000000013b8 <+168>:   callq  0x12c0 <_ZNSt6thread6detachEv@plt>
0x00000000000013bd <+173>:   cmpq   $0x0,0x8(%rsp)   # while (true)
0x00000000000013c3 <+179>:   jne    0x14a0 <main()+400>
0x00000000000013c9 <+185>:   sub    $0x1,%ebx
0x00000000000013cc <+188>:   jne    0x1378 <main()+104>
0x00000000000013ce <+190>:   xchg   %ax,%ax
0x00000000000013d0 <+192>:   mov    0x2db6(%rip),%eax        # 0x418c <times>
0x00000000000013d6 <+198>:   cmp    $0xa,%eax        # if 
0x00000000000013d9 <+201>:   jne    0x13d0 <main()+192>
0x00000000000013db <+203>:   lea    0x2c5e(%rip),%r12        # 0x4040 <_ZSt4cout@@GLIBCXX_3.4>
0x00000000000013e2 <+210>:   lea    0xc1b(%rip),%rsi        # 0x2004
0x00000000000013e9 <+217>:   mov    %r12,%rdi
0x00000000000013ec <+220>:   callq  0x1230 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
```
