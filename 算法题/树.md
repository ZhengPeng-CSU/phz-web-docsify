# 二叉树的遍历
前序，中序，后续遍历用递归实现比较容易，主要是要熟悉非递归的实现。
前序遍历，这个比较简单，
1. 根节点入栈
2. 每次弹出栈顶，然后右子树入栈，再左子树入栈
```C++
std::vector<int32_t> preorderTraversal(TreeNode* root) {
    std::vector<int32_t> result;
    if (root == nullptr) {
        return result;
    }
    std::stack<TreeNode*> node_st;
    // 1. 先把根节点入栈
    node_st.push(root);
    while (!node_st.empty()) {
        auto cur = node_st.top();
        node_st.pop();
        result.emplace_back(cur->val);
        // 2. 左右节点判断是否为空，不为空则入栈，注意是右子树先入栈，因为出栈时要先遍历左子树
        if (cur->right != nullptr) {
            node_st.push(cur->right);
        }
        if (cur->left != nullptr) {
            node_st.push(cur->left);
        }
    }
    return result;
}
```
中序遍历，稍微有点复杂，也是借助栈来实现
1. 记录当前节点为根节点
2. 当前节点的左子树不断入栈，直到为空
3. 取栈顶，此时就是最左边的子树
4. 右子树入栈
```C++
std::vector<int32_t> inorderTraversal(TreeNode* root) {
    std::vector<int32_t> result;
    if (root == nullptr) {
        return result;
    }
    std::stack<TreeNode*> node_st;
    // 1. 记录当前节点为根节点
    auto cur = root;
    while (cur != nullptr || !node_st.empty()) {
        // 2. 当前节点的左子树不断入栈，直到为空
        while (cur != nullptr) {
            node_st.push(cur);
            cur = cur->left;
        }
        // 3. 取栈顶，此时就是最左边的子树
        auto top = node_st.top();
        node_st.pop();
        // 4. 右子树入栈
        result.emplace_back(top->val);
        cur = top->right;
    }

    return result;
}
```
后序遍历
1. 申请两个栈，根节点入第一个栈
2. 栈1的栈顶入栈2，然后栈顶的左右子树分别入栈
3. 不断弹出栈2就是后序遍历
```C++
std::vector<int32_t> postorderTraversal(TreeNode* root) {
    std::vector<int32_t> result;
    if (root == nullptr) {
        return result;
    }
    // 1. 两个栈，根节点入第一个栈
    std::stack<TreeNode*> node_st1;
    std::stack<TreeNode*> node_st2;
    node_st1.push(root);
    while (!node_st1.empty()) {
        auto cur = node_st1.top();
        node_st1.pop();
        // 2. 栈1的栈顶入栈2，然后栈顶的左右子树分别入栈
        node_st2.emplace(cur);
        if (cur->left) {
            node_st1.push(cur->left);
        }
        if (cur->right) {
            node_st1.push(cur->right);
        }
    }
    // 3. 不断弹出栈2就是后序遍历
    while (!node_st2.empty()) {
        result.emplace_back(node_st2.top()->val);
        node_st2.pop();
    }
    return result;
}
```

层序遍历，这个没有递归写法，利用队列来实现，基本思路就是每次遍历当前节点时分别把左右子树入栈，每一层遍历前记录一下数量来实现分层
```C++
vector<vector<int>> levelOrder(TreeNode* root) {
    std::vector<std::vector<int32_t>> result;
    if (root == nullptr) {
        return result;
    }
    std::queue<TreeNode*> node_que;
    node_que.push(root);
    while (!node_que.empty()) {
        auto size = node_que.size();
        std::vector<int32_t> level;
        while(size-- > 0) {
            auto cur = node_que.front();
            level.emplace_back(cur->val);
            node_que.pop();
            if (cur->left != nullptr) {
                node_que.push(cur->left);
            }
            if (cur->right != nullptr) {
                node_que.push(cur->right);
            }
        }
        if (!level.empty()) {
            result.emplace_back(level);
        }
    }

    return result;
}
```

# 合并两个二叉树
```C++
TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
    if (root1 == nullptr) {
        return root2;
    }
    if (root2 == nullptr) {
        return root1;
    }
    TreeNode* root = new TreeNode(root1->val + root2->val);
    root->left = mergeTrees(root1->left, root2->left);
    root->right = mergeTrees(root1->right, root2->right);
    return root;
}
```
然后精髓还是在非递归的做法，其实非递归就是运用自定定义的栈或者队列来模拟递归，二叉树大部分操作就是遍历，这里就是前序遍历的写法
```C++
TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2){
    if (root1 == nullptr) {
        return root2;
    }
    if (root2 == nullptr) {
        return root1;
    }
    using NodePair = std::pair<TreeNode*, TreeNode*>;
    std::stack<NodePair> node_st;
    node_st.push({root1, root2});
    while (!node_st.empty()) {
        auto [cur1, cur2] = node_st.top();
        node_st.pop();
        cur1->val += cur2->val;
        if (cur1->right != nullptr && cur2->right != nullptr) {
            node_st.push({cur1->right, cur2->right});
        }
        if (cur1->left != nullptr && cur2->left != nullptr) {
            node_st.push({cur1->left, cur2->left});
        }
        if (cur1->left == nullptr) {
            cur1->left = cur2->left;
        }
        if (cur1->right == nullptr) {
            cur1->right = cur2->right;
        }
    }
    return root1;
}
```

# 二叉树高度
递归，左右分别递归
```C++
int maxDepth(TreeNode* root) {
    if (root == nullptr) {
        return 0;
    }
    return 1 + std::max(maxDepth(root->left), maxDepth(root->right));
}
```
然后利用高度判断是不是二叉平衡树，注意空的时候返回true
```C++
bool isBalanced(TreeNode* root) {
    if (root == nullptr) {
        return true;
    }
    auto left = MaxDepth(root->left);
    auto right = MaxDepth(root->right);
    if (std::abs(left - right) >= 2) {
        return false;
    }
    if (!isBalanced(root->left)) {
        return false;
    }
    if (!isBalanced(root->right)) {
        return false;
    }
    return true;
}
```

# 二叉树翻转
还是递归写法，注意这种写法，左右子树分别递归。
```C++
TreeNode* invertTree(TreeNode* root) {
    if(root == nullptr) {
        return nullptr;
    }
    root->left = invertTree(root->left);
    root->right = invertTree(root->right);
    std::swap(root->left, root->right);
    return root;
}
```

# 二叉树对称
这题其实挺巧妙的，一颗二叉树分别左右递归进行比较
```C++
bool SymCompare(TreeNode* root1, TreeNode* root2) {
    if (root1 == nullptr && root2 == nullptr) {
        return true;
    }
    if (root1 == nullptr ||root2 == nullptr) {
        return false;
    }
    if (root1->val != root2->val) {
        return false;
    }
    if (!SymCompare(root1->left, root2->right)) {
        return false;
    }
    if (!SymCompare(root1->right, root2->left)) {
        return false;
    }
    return true;
}

bool isSymmetric(TreeNode* root) {
    return SymCompare(root, root);
}
```

# 二叉搜索树的第N大的节点
二叉搜索树的中序遍历是一个递增的序列，所以无法直接找到第N大的数，因此我们需要反向遍历。也就是说，中序遍历的时候左右对换一下得到的就是递减序列，每次经过一个节点，计数-1就行了。
注意计数要写引用。
```C++
void InOrder(TreeNode* root, int& cnt, int& result) {
    if (root == nullptr) {
        return;
    }
    // 反向中序遍历
    InOrder(root->right, cnt, result);
    cnt--;
    if (cnt == 0) {
        result = root->val;
    }
    InOrder(root->left, cnt, result);
} 

int findTargetNode(TreeNode* root, int cnt) {
    int result = 0;
    InOrder(root, cnt, result);
    return result;
}
```
