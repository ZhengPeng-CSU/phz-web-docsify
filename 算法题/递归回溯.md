# 电话号码的组合
这题可以说是递归回溯的启蒙题和标准写法了，递归的几个关键参数，路径，目标，当前位置，原始数据和结果可以通过lambda来捕获，像这题其实是不需要目标这个参数的，因为判断路径的长度就可以递归终止了。

# 括号生成
这题在标注的递归上加上了裁枝的操作，所谓裁枝呢，就是提前找到一些递归终止条件或者跳过的条件。比如我们比裁剪就是全部遍历，然后通过有效括号来判断是否满足。
原始数据只有两个可选，即"()"。而路径就是当前括号生成的结果，n对括号就是2n的总长度字符串，递归终止就是长度够了然后判断是否是有效括号。
而加上裁剪以后就会提前去判断这个路径要不要走，路径在这里就是判断能不能添加一个右括号或者左括号。
```C++
std::vector<std::string> generateParenthesis(int32_t n) {
    std::vector<std::string> result;
    std::function<void(const std::string&, int32_t, int32_t)> dfs = [this, &dfs, &result, n](const std::string& path, int32_t left, int32_t right) {
        // 终止递归
        if (left > n || right > n) {
            return;
        }
        // 终止递归并添加结果
        if (left == n && right == n) {
            result.emplace_back(path);
            return;
        }
        // 左括号小于n个，还可以添加左括号
        if (left < n) {
            dfs(path + '(', left + 1, right);
        }
        // 右括号要小于n个，且小于左括号才可添加
        if (right < n && right < left) {
            dfs(path + ')', left, right + 1);
        }
    };
    dfs("", 0, 0);
    return result;
}
```

