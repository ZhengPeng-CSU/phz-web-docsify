# 最长回文子串
中心扩散法

# 字符串转整数
处理溢出

# 无重复的最长子串
滑动窗口计数

# 罗马数字转换

# 字符串异位分组
这题如果对每一个字符串进行排序则比较简单，而我比较关注的是实用哈希的方式，相当于我们自定义一个哈希函数，结合unordered_map来使用。
```C++
std::vector<std::vector<std::string>> groupAnagrams(vector<string>& strs) {
	using AlphaArray = std::array<int, 26>;
    // 哈希函数
	auto hash_func = [](const AlphaArray& str) {
		std::string result;
		char alpha = 'a';
		for (const auto num : str) {
			if (num != 0) {
				result.append(num, alpha);
			}
			alpha++;
		}
        // 根据每一个字符的数量组装成字符串，然后返回一个哈希值
		return std::hash<std::string>()(result);
	};
	std::vector<std::vector<std::string>> result;
	int32_t index = 0;
    // 自定义哈希函数的unordered_map
	std::unordered_map<AlphaArray, int32_t, decltype(hash_func)> record(10, hash_func);
	for (const auto& str : strs) {
		AlphaArray alpha_count{0};
        // 统计每个字符出现的次数
		for (const auto c : str) {
			alpha_count[c - 'a']++;
		}
		if (auto iter = record.find(alpha_count); iter != record.end()) {
			result[iter->second].emplace_back(str);
		} else {
			record[alpha_count] = index++;
			result.emplace_back(std::vector{str});
		}
	}
	return result;
}
```


