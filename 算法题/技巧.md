# 盛水最多的容器
双指针
```C++
int maxArea(vector<int>& height) {
    if (height.size() < 2) {
        return 0;
    }
    int32_t left = 0;
    int32_t right = height.size() - 1;
    int32_t result = 0;
    while (left < right) {
        auto cur = (right - left) * std::min(height[left], height[right]);
        result = std::max(result, cur);
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    return result;
}
```

# 多数之和
两数之和非常简单，基本都能写出来，三数之和要使用去重和双指针的技巧了。
去重一般都要先排序，并且一般都是用nums[i] == nums[i - 1]来continue，三数之和有两层循环，外层可以直接这样去重，但是内层必须要和满足的时候才能移动指针去重，否则就会漏结果。
而双指针在这里的作用有点类似二分时候移动左右边界，也就是移动左指针还是右指针，移动条件是left < right。
最接近的三数之后思路基本一致，就是外层如果做循环跳过处理的时候要注意不能直接return。
四数之和就是再加一层循环，没啥意义。

# 二分查找
二分查找是非常经典的技巧，首先是标准的二分查找，用来在排序数组中判断指定的数字是否存在或者找到下界与上界等。
我们可以先熟悉下STL种与二分查找相关的4个算法，
（1）std::binary_search查找元素是否存在，注意返回的是bool而不是索引
（2）std::lower_bound返回第一个不小于指定元素的位置，std::upper_bound返回第一个大于给定元素的位置
（3）

```C++
int BinarySearch(std::vector<int32_t> nums, int32_t target) {
    // 1. 注意左右边界
    int32_t left = 0; 
    int32_t right = nums.size() - 1;
    // 2. 注意循环条件
    while(left <= right) {
        // 3. 注意中间值计算
        int mid = left + (right - left) / 2;
        if(nums[mid] == target) {
            return mid; 
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        }
    }
    return -1;
}
```
stl中的binary_search就是二分，不过它返回的是元素是否存在，而不是索引。
（1）第一个变体是查找数组中元素的第一个位置和最后一个位置
我们先用stl的算法来实现，就比较较简单
```C++
std::vector<int> searchRange(const std::vector<int>& nums, int target) {
    std::vector<int> result{-1, -1};
    auto first = std::lower_bound(nums.begin(), nums.end(), target);
    if (first == nums.end() || *first != target) {
        return result;
    }
    auto second = std::upper_bound(nums.begin(), nums.end(), target);
    result[0] = std::distance(nums.begin(), first);
    result[1] = std::distance(nums.begin(), second) - 1;
    return result;
}
```
接下来我们自己通过二分实现lower_bound和upper_bound就可以了，
```C++
std::vector<int> searchRange(const std::vector<int>& nums, int target) {
    std::vector<int> result{-1, -1};
    // lower_bound
    auto lower_bound = [](const std::vector<int>& nums_in, int target_in) {
        int32_t left = 0;
        int32_t right = nums_in.size() - 1;
        while (left <= right) {
            auto mid = left + (right - left) / 2;
            if (nums_in[mid] >= target_in) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    };
    auto upper_bound = [](const std::vector<int>& nums_in, int target_in) {
        int32_t left = 0;
        int32_t right = nums_in.size() - 1;
        while (left <= right) {
            auto mid = left + (right - left) / 2;
            if (nums_in[mid] <= target_in) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return right;
    };
    auto first = lower_bound(nums, target);
    if (first == nums.size() || nums[first] != target) {
        return result;
    }
    auto second = upper_bound(nums, target);
    result[0] = first;
    result[1] = second;
    return result;
}
```
(2) 搜索旋转数组，找到最小元素和查找指定元素，思路都是一样的，先找到最小元素，也就是旋转点，然后再次二分查找。其实关键还是第一步，
```C++
int findMin(vector<int>& nums) {
    int left = 0;
    int right = nums.size() - 1;
    // 这里不是升序数组，循环条件不一样，没有等于
    while (left < right) {
        // 这个取整的时候是靠近左边界的
        auto mid = left + (right - left) / 2;
        if (nums[mid] > nums[right]) {
            left = mid + 1;
        } else {
            // 右边界不能+1，否则可能错过分割的点
            right = mid;
        }
    }
    return nums[left];
}

int search(const std::vector<int>& nums, int target) {
    auto find_min = [](const std::vector<int>& nums_in) {
        int left = 0;
        int right = nums_in.size() - 1;
        while (left < right) {
            auto mid = left + (right - left) / 2;
            if (nums_in[mid] > nums_in[right]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    };
    // 第一步，找到最小元素
    auto min_index = find_min(nums);
    if (target == nums[min_index]) {
        return min_index;
    }
    int left = 0;
    int right = nums.size() - 1;
    // 如果min_index为0，说明没有发生旋转
    if (min_index > 0) {
        // 确定二分的左右边界，比较target和nums[0]
        if (target >= nums[0]) {
            right = min_index - 1;
        } else {
            left = min_index;
        }
    }
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] == target) {
            return mid; 
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        }
    }
    return -1;
}
```

(3)搜索二维矩阵，这题其实也是两次二分查找，第一次找到行，第二次在行中进行二分，这里我们选择对最后一列进行二分，二分完以后左边界就是所在行了。
```C++
bool searchMatrix(std::vector<std::vector<int>>& matrix, int target) {
    int top = 0;
    int bot = matrix.size() - 1;
    while (top < bot) {
        int mid = top + (bot - top) / 2;
        if (matrix[mid][0] > target) {
            bot = mid;
        } else {
            top = mid + 1;
        }
    }
    int left = 0;
    int right = matrix[top].size();
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (matrix[mid][left] == target) {
            return true;
        } else if (matrix[mid][left] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return false;
}
```
而比较难的一题是二维矩阵2这题，由于列之间不是升序的，所以上面二分两次就不适用了，当然我们还可以每一行遍历二分一次。而这题的解决思路有点类似二分，
从左下角开始查找，如果要target比它大，说明往右边走就行了，如果target比它小，说明要往上走。
```C++
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int m = matrix.size() - 1;
    int n = matrix[0].size() - 1;
    int i = m;
    int j = 0;
    while (i >= 0 && j <= n) {
        // 这里其实就是二分查找的思想
        if (matrix[i][j] == target) {
            return true;
        } else if (matrix[i][j] > target) {
            i--;
        } else {
            j++;
        }
    }
    return false;
}
```
这个思路对于上面那题也是使用的，不过此时负责度就是线性级别而不是对数级别了。
