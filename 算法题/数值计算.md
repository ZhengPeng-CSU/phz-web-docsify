# 整数反转
整数反转本身的逻辑是简单的，但是不能使用64位时要处理溢出会比较麻烦。int32_t的范围是[-2,147,483,648, 2,147,483,647]，反转的时候可能导致越界。
越界判断在字符串转数字这题里面也会用到，而这里的整数反转可以稍微简单一些。通常来说我们判断反转是拿INT_MAX和INT_MIN去除10来判断，然后再比较个位，整数反转由于最高位最多是2，所以个位其实不用判断。不过位了通用，我们可以写一个同一的判断越界的函数is_outof_boundary，它接受三个参数，
第一个是当前这一位的数值，
第二个是已经累加的和，
第三个是正数还是负数。
不过这里我们限制传入的sum和cur_place都是正的，换句话说，我们需要把负数转成正的来判断，转换的时候不能直接乘-1，INT_MIN必须特殊处理。
```C++
int reverse(int x) {
    // 用来判断溢出的函数
    auto is_outof_boundary = [](int32_t cur_place, int32_t sum, bool positive) {
        // 判断正数是否溢出
        if (positive > 0) {
            // 说明再乘以10肯定会溢出的
            if (INT32_MAX / 10 < sum) {
                return true;
            }
            // 位数相等，就要判断个位是不是大于2,147,483,647的7
            if (INT32_MAX / 10 == sum && cur_place > INT32_MAX % 10) {
                return true;
            }
        } else {
            // 判断负数是否溢出
            if (abs(INT32_MIN / 10) < sum) {
                return true;
            }
            // 位数相等，就要判断个位是不是大于-2,147,483,648的8
            if (abs(INT32_MIN / 10) == sum && cur_place >= abs(INT32_MIN % 10)) {
                return true;
            }
        }
        return false;
    }; 
    int32_t value = x;
    int32_t result = 0;
    bool positive = (x > 0);
    if (!positive) {
        if (value == INT32_MIN) {
            return 0;
        }
        value = -value;
    }
    while (value != 0) {
        int32_t cur_place = value % 10;
        if (is_outof_boundary(cur_place, result, positive)) {
            return 0;
        }
        result = result * 10 + cur_place;
        value /= 10;
    }
    return positive ? result : -result; 
}
```
# 两数相除
两数相除，本质上就是一个个的累加求和得到商，但是这样的速度太慢了，所以关键就是如何加速，这里的算法就是倍增，也就是每次累加的sum是直接sum翻倍而不是加上除数。
然后还有一个技巧是全部转乘负数来处理，因为负数能表示的范围更大。不过我觉得还是正数看起来比较容易理解，所以直接用int64_t来处理吧，


# 快速幂
求幂其实就是累乘，但是和累加一样，这样直接循环速度太慢了，所以需要倍增来加速。base每次不是乘以x，而是乘以base自己，然后指数直接除2。
比如2 ^8 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2
这样要循环8次，很慢，倍增则是
第一次是2 * 2，下一次 2 * 2 * 2 * 2，再来一次就得到结果了
    8 -> 4 -> 2 -> 1
  循环 : 1     2     3


