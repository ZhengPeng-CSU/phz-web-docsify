# 编译和静态链接
我们知道，Linux中的可执行文件是ELF格式，代码经过编译和链接以后才能得到可执行文件，装载后运行就是一个进程。所以，我个人的学习路线是从了解一个elf文件是如何  
编译出来开始，再学习其实如何装载运行以及调度的，从而一窥整个linux下进程管理的全貌。

## 编译和链接的基本概念
我们在使用gcc/g++编译实际上是有4个阶段，预处理，编译，汇编，链接  
1、预处理展开头文件和处理宏，删除注释，添加行号标识；  
2、对预处理的文件进行词法分析、语法分析和语义分析，生成汇编代码，gcc实际上将预处理和编译合成了一个步骤，  
&emsp;使用ccl这个程序，gcc只是对这些命令的包装，汇编器as，链接器ld，这也是编译优化发生的一步；  
3、汇编是将汇编代码转成机器码，汇编以后得到就是elf三个类型之一，目标文件。  
4、链接，链接输出可执行文件。    

编译器可以分为前端和后端两个部分，前端负责词法分析、语法分析、语义分析，中间代码生成，源代码优化器将整个语法树转换成中间代码，中间代码是机器无关的，  
所以中间代码将编译器分成了前端和后端，前端负责产生机器无关的中间代码，后端将中间代码转换成目标机器代码。
链接器处理好各个模块之间相互引用的部分，主要包括地址和空间分配、符号决议和重定位

## 目标文件格式
编译生成的是目标文件，也就是.o文件，目标文件是ELF格式。ELF有4种类型，目标文件、可执行文件、共享文件和核心转储文件。静态库不是目标文件，它是目标文件通过打包得到的合集。  
目标文件通常以section描述，ELF文件都有一个header，描述了整个文件的属性。ELF的header标识了段表的位置，段表实际上就是一个描述各个section在文件中偏移位置和属性的数组，  
header后面就是各个section的内容了。

![section](../../source/images/目标文件格式.png ':size=40%')

### 1. elf格式
内核中对elf的定义如下，对于32和64位版本来说只是成员的大小不一样，include\uapi\linux\elf.h
```C++
typedef struct elf64_hdr {
    unsigned char e_ident[EI_NIDENT]; /* ELF魔数 */
    Elf64_Half e_type;    /* 文件类型，.o可重定位文件，可执行文件以及共享目标文件.so */    
    Elf64_Half e_machine; /* 平台属性 */
    Elf64_Word e_version; /* 版本号 */
    Elf64_Addr e_entry;   /* 入口地址，ELF程序的入口虚拟地址，操作系统在加载
                        完该程序后从这个地址开始执行进程指令，可重定位文件没有入口地址，为0 */
    Elf64_Off e_phoff;    /* Program header table file offset */
    Elf64_Off e_shoff;    /* 段表在文件中的偏移，即段表的位置 */
    Elf64_Word e_flags;   
    Elf64_Half e_ehsize;  /* ELF本身的大小 */
    Elf64_Half e_phentsize;
    Elf64_Half e_phnum;
    Elf64_Half e_shentsize; /* 段描述符大小，就是段表结构体大小 */
    Elf64_Half e_shnum;     /* 段描述符数量，也就是ELF中段的数量 */
    Elf64_Half e_shstrndx;  /* 段表字符串表在段表中的索引下标 */
} Elf64_Ehdr;
```

### 2. 段表描述符
可以看到，ELF的文件类型并不是通过扩展名来表示的，而是上面的e_type。前面文件头里面标识了段表的位置e_shoff，再配合段表字符串表就能得到整个ELF段的内容。  
所谓段表描述符就是一个结构体，段表就是一个结构体数组，每个结构体对应一个段，第一个元素是无效的段描述符。  
通过objdump -h 可以查看目标文件的header，通过size可以查看目标文件的各个section的长度。  
![objdump_h](../../source/images/objdump_h.png ':size=40%')

段表描述符结构体定义格式如下，  
```C++
typedef struct elf32_shdr {
    Elf32_Word  sh_name;    //段名在字符串表中的偏移
    Elf32_Word  sh_type;    //段的类型
    Elf32_Word  sh_flags;   //段的标志位
    Elf32_Addr  sh_addr;    //段虚拟地址
    Elf32_Off   sh_offset;  //段偏移
    Elf32_Word  sh_size;    //段的长度
    Elf32_Word  sh_link;    
    Elf32_Word  sh_info;    //链接信息
    Elf32_Word  sh_addralign;//段地址对齐
    Elf32_Word  sh_entsize;
} Elf32_Shdr;
```
段的名字对于编译器和链接器有意义，但是对于操作系统来说没有意义，操作系统如何处理一个段取决于它的属性和权限，由段的类型和标志位决定。段类型包括，   
```C++
#define SHT_NULL  0         //无效段
#define SHT_PROGBITS  1     //程序段
#define SHT_SYMTAB  2       //符号表
#define SHT_STRTAB  3       //字符串表
#define SHT_RELA  4         //重定位表
#define SHT_HASH  5         //符号表的哈希表
#define SHT_DYNAMIC 6       //动态链接信息
#define SHT_NOTE  7         //提示性信息
#define SHT_NOBITS  8       //该段无内容，如bss段
#define SHT_REL   9         //该段包含了重定位信息
#define SHT_SHLIB 10        
#define SHT_DYNSYM  11      //动态链接符号表
#define SHT_NUM   12
```
标志位表示该段在进程虚拟地址空间的属性
```C++
#define SHF_WRITE   0x1   //可写
#define SHF_ALLOC   0x2   //该段需要在进程空间中分配空间
#define SHF_EXECINSTR   0x4 //可执行
```
接下来我们具体的看看每个section的作用，一个section就对应一个段表项。   
.text : 代码段编译好的二进制代码。代码段就没啥好说的了。值得一提的是为什么代码段和数据段要区分开，一方面是区分权限，另一方面是实现数据缓存和指令缓存分离，  
提高CPU缓存命中率，最重要的是实现多个程序指令共享。 

.data：初始化好的全局和静态变量  

.rodata : 只读数据，如字符串常量，const变量比如printf中的参数，就是字符串常量。有些编译器会把字符串常量放到.data段。  

.bss : 未初始化的全局变量和静态变量。有些编译器会把全局的未初始化变量放到bss段，有些则不会，比如gcc只是预留一个未定义的全局变量符号，等到最终链接的时候再在bss段分配空间。  
所以查看符号表，data段和bss段都是看不到未定义的全局变量符号的。但是如果这个全局变量执行了赋值操作，则能看到一个未定义符号，  
0000000000000000         *UND*  0000000000000000 g_aaa  
全局变量不能在函数内部定义初始化，可以先定义再赋值，也可看到这个未定义符号。  
不管是函数内部还是外部的静态全局变量，只要没初始化都是放到bss段。注意是初始化，所以即使先定义了，之后赋值是不算初始化的。  
全局变量或者静态变量只要初始化为0，都会放到bss段，这点很有意思。  
bss段是不占大小的，只在文件头记录应该预留的空间，使用size命令读取的是头部信息所以显示有大小。正是因为不占空间，所以初始化为0会放到bss段。  

.strtab : 字符串表、变量名。字符串表.strtab用来保存符号的名字，段表字符串表.shstrtab用来保存段表中用到的字符串。
![字符串表的形式](../../source/images/字符串表.png ':size=40%')  
字符串表中的第一个字符串(序号为 0)永远是”null”,它用于表示一个空的名字或者没有名字。所以,字符串表的第一个字节是"null"。字符串表也可以是空的,不含有任何字符串,这时, 结构体中的sh_size为0。
每一个节头的sh_name成员应该是一个索引值,它指向段表字符串表中的一个位置，从这个位置开始到接下来第一个"null"字符为止的这个字符串,正是这个节的名字。  

.symtab ：符号表，记录的是函数和变量。我们在调试的时候经常说到的符号表就是指这个，把函数和变量统称为符号。链接的过程就是符号的管理，符号值就是地址。符号表中的符号类型分为，  
（1）定义在本目标文件的全局符号：可以被其他目标文件引用  
（2）在本目标引用的全局符号：也就是外部符号  
（3）段名：由编译器产生，它的值就是该段的起始地址  
（4）局部符号：静态变量  
（5）行号信息    
查看符号表 nm 目标文件

重定位表 ： 每一个需要重定位的代码段或数据段都有一个相应的重定位表.rel.data，.rel.text。  

### 3. 符号表
符号是链接的接口，链接的本质就是拼接各个目标文件的符号，每个目标文件都有自己的符号表，记录了目标文件中所用到的所有符号，每个定义的符号都有符号值，变量和函数的符号值就是他们的地址。elf文件中的符号表示一个单独的section，就是上面说的.symtab，符号表这个段里面存储的结构本身也是一个数组，数组下标为0固定表示一个未定义的无效符号，这个结构体的定义在include\uapi\linux\elf.h  
```C++
typedef struct elf32_sym{
    Elf32_Word  st_name;       //符号名，即该符号名在字符串表中的索引
    Elf32_Addr  st_value;      //符号值，对于变量和函数来说就是地址
    Elf32_Word  st_size;       //符号大小，0表示未知
    unsigned char st_info;     //符号类型和绑定信息
    unsigned char st_other;    //没用
    Elf32_Half  st_shndx;      //符号所在段索引
} Elf32_Sym;
```
符号名：这个无需多说，就是个index索引，符号名也是个字符串，保存在字符串表中。    
符号类型和绑定信息：低4位表示符号的类型，不知道为啥都说高28位表示符号绑定信息，是字节对齐了还是咋的，哪来的4个字节？  
符号绑定信息和符号类型，定义如下，  
```C++
#define STB_LOCAL  0  //局部符号
#define STB_GLOBAL 1  //全局符号
#define STB_WEAK   2  //弱引用
```
符号类型
```C++
#define STT_NOTYPE  0   //未知类型
#define STT_OBJECT  1   //数据对象，如数组、变量
#define STT_FUNC    2   //函数或可执行代码
#define STT_SECTION 3   //符号表示一个段，必须是STB_LOCAL
#define STT_FILE    4   //文件名，一般是目标文件的文件名
#define STT_COMMON  5
#define STT_TLS     6
```
符号所在段：如果符号定义在本目标文件中，那么就是这个符号所在段在段表中的下标。如果不是定义在本目标文件中或者部分符号则有些特殊，
```C++
#define SHN_UNDEF 0           //定义在其他文件中的符号
#define SHN_LORESERVE 0xff00
#define SHN_LOPROC  0xff00
#define SHN_HIPROC  0xff1f
#define SHN_LIVEPATCH 0xff20
#define SHN_ABS   0xfff1      //一个绝对的值，比如文件名的符号
#define SHN_COMMON  0xfff2    //“COMMON”块类型的符号，如未初始化的全局符号定义
#define SHN_HIRESERVE 0xffff  
```
符号值：简单说符号值就是地址，但是实际比较复杂：
（1）在目标文件中，如果符号不是COMMON块类型的，则st_value表示该符号在段中的偏移，即由st_shndx指定的段偏移的位置，这是目标文件中全局变量符号最常见的情况；  
（2）在目标文件中，符号是COMMON块类型的，表示该符号的对齐属性；  
（3）在可执行文件中，表示符号的虚拟地址。  
