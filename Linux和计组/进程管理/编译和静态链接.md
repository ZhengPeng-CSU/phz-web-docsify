# 编译和静态链接
我们知道，Linux中的可执行文件是ELF格式，代码经过编译和链接以后才能得到可执行文件，装载后运行就是一个进程。所以，我个人的学习路线是从了解一个elf文件是如何  
编译出来开始，再学习其实如何装载运行以及调度的，从而一窥整个linux下进程管理的全貌。

## 编译和链接的基本概念
我们在使用gcc/g++编译实际上是有4个阶段，预处理，编译，汇编，链接  
1、预处理展开头文件和处理宏，删除注释，添加行号标识；  
2、对预处理的文件进行词法分析、语法分析和语义分析，生成汇编代码，gcc实际上将预处理和编译合成了一个步骤，  
&emsp;使用ccl这个程序，gcc只是对这些命令的包装，汇编器as，链接器ld，这也是编译优化发生的一步；  
3、汇编是将汇编代码转成机器码，汇编以后得到就是elf三个类型之一，目标文件。  
4、链接，链接输出可执行文件。    

编译器可以分为前端和后端两个部分，前端负责词法分析、语法分析、语义分析，中间代码生成，源代码优化器将整个语法树转换成中间代码，中间代码是机器无关的，  
所以中间代码将编译器分成了前端和后端，前端负责产生机器无关的中间代码，后端将中间代码转换成目标机器代码。
链接器处理好各个模块之间相互引用的部分，主要包括地址和空间分配、符号决议和重定位

## 目标文件格式
编译生成的是目标文件，也就是.o文件，目标文件是ELF格式。ELF有4种类型，目标文件、可执行文件、共享文件和核心转储文件。静态库不是目标文件，它是目标文件通过打包得到的合集。  
目标文件通常以section描述，ELF文件都有一个header，描述了整个文件的属性。ELF的header标识了段表的位置，段表实际上就是一个描述各个section在文件中偏移位置和属性的数组，  
header后面就是各个section的内容了。

![section](../../source/images/目标文件格式.png ':size=40%')

### 1. elf格式
内核中对elf的定义如下，对于32和64位版本来说只是成员的大小不一样，include\uapi\linux\elf.h
```C++
typedef struct elf64_hdr {
    unsigned char e_ident[EI_NIDENT]; /* ELF魔数 */
    Elf64_Half e_type;    /* 文件类型，.o可重定位文件，可执行文件以及共享目标文件.so */    
    Elf64_Half e_machine; /* 平台属性 */
    Elf64_Word e_version; /* 版本号 */
    Elf64_Addr e_entry;   /* 入口地址，ELF程序的入口虚拟地址，操作系统在加载
                        完该程序后从这个地址开始执行进程指令，可重定位文件没有入口地址，为0 */
    Elf64_Off e_phoff;    /* Program header table file offset */
    Elf64_Off e_shoff;    /* 段表在文件中的偏移，即段表的位置 */
    Elf64_Word e_flags;   
    Elf64_Half e_ehsize;  /* ELF本身的大小 */
    Elf64_Half e_phentsize;
    Elf64_Half e_phnum;
    Elf64_Half e_shentsize; /* 段描述符大小，就是段表结构体大小 */
    Elf64_Half e_shnum;     /* 段描述符数量，也就是ELF中段的数量 */
    Elf64_Half e_shstrndx;  /* 段表字符串表在段表中的索引下标 */
} Elf64_Ehdr;
```

### 2. 段表描述符
可以看到，ELF的文件类型并不是通过扩展名来表示的，而是上面的e_type。前面文件头里面标识了段表的位置e_shoff，再配合段表字符串表就能得到整个ELF段的内容。  
所谓段表描述符就是一个结构体，段表就是一个结构体数组，每个结构体对应一个段，第一个元素是无效的段描述符。  
通过objdump -h 可以查看目标文件的header，通过size可以查看目标文件的各个section的长度。  
![objdump_h](../../source/images/objdump_h.png ':size=40%')

段表描述符结构体定义格式如下，  
```C++
typedef struct elf32_shdr {
    Elf32_Word  sh_name;    //段名在字符串表中的偏移
    Elf32_Word  sh_type;    //段的类型
    Elf32_Word  sh_flags;   //段的标志位
    Elf32_Addr  sh_addr;    //段虚拟地址
    Elf32_Off   sh_offset;  //段偏移
    Elf32_Word  sh_size;    //段的长度
    Elf32_Word  sh_link;    
    Elf32_Word  sh_info;    //链接信息
    Elf32_Word  sh_addralign;//段地址对齐
    Elf32_Word  sh_entsize;
} Elf32_Shdr;
```
段的名字对于编译器和链接器有意义，但是对于操作系统来说没有意义，操作系统如何处理一个段取决于它的属性和权限，由段的类型和标志位决定。段类型包括，   
```C++
#define SHT_NULL  0         //无效段
#define SHT_PROGBITS  1     //程序段
#define SHT_SYMTAB  2       //符号表
#define SHT_STRTAB  3       //字符串表
#define SHT_RELA  4         //重定位表
#define SHT_HASH  5         //符号表的哈希表
#define SHT_DYNAMIC 6       //动态链接信息
#define SHT_NOTE  7         //提示性信息
#define SHT_NOBITS  8       //该段无内容，如bss段
#define SHT_REL   9         //该段包含了重定位信息
#define SHT_SHLIB 10        
#define SHT_DYNSYM  11      //动态链接符号表
#define SHT_NUM   12
```
标志位表示该段在进程虚拟地址空间的属性
```C++
#define SHF_WRITE   0x1   //可写
#define SHF_ALLOC   0x2   //该段需要在进程空间中分配空间
#define SHF_EXECINSTR   0x4 //可执行
```
接下来我们具体的看看每个section的作用，一个section就对应一个段表项。   
.text : 代码段编译好的二进制代码。代码段就没啥好说的了。值得一提的是为什么代码段和数据段要区分开，一方面是区分权限，另一方面是实现数据缓存和指令缓存分离，  
提高CPU缓存命中率，最重要的是实现多个程序指令共享。 

.data：初始化好的全局和静态变量  

.rodata : 只读数据，如字符串常量，const变量比如printf中的参数，就是字符串常量。有些编译器会把字符串常量放到.data段。  

.bss : 未初始化的全局变量和静态变量。有些编译器会把全局的未初始化变量放到bss段，有些则不会，比如gcc只是预留一个未定义的全局变量符号，等到最终链接的时候再在bss段分配空间。  
所以查看符号表，data段和bss段都是看不到未定义的全局变量符号的。但是如果这个全局变量执行了赋值操作，则能看到一个未定义符号，  
0000000000000000         *UND*  0000000000000000 g_aaa  
全局变量不能在函数内部定义初始化，可以先定义再赋值，也可看到这个未定义符号。  
不管是函数内部还是外部的静态全局变量，只要没初始化都是放到bss段。注意是初始化，所以即使先定义了，之后赋值是不算初始化的。  
全局变量或者静态变量只要初始化为0，都会放到bss段，这点很有意思。  
bss段是不占大小的，只在文件头记录应该预留的空间，使用size命令读取的是头部信息所以显示有大小。正是因为不占空间，所以初始化为0会放到bss段。  

.strtab : 字符串表、变量名。字符串表.strtab用来保存符号的名字，段表字符串表.shstrtab用来保存段表中用到的字符串。
![字符串表的形式](../../source/images/字符串表.png ':size=40%')  
字符串表中的第一个字符串(序号为 0)永远是”null”,它用于表示一个空的名字或者没有名字。所以,字符串表的第一个字节是"null"。字符串表也可以是空的,不含有任何字符串,这时, 结构体中的sh_size为0。
每一个节头的sh_name成员应该是一个索引值,它指向段表字符串表中的一个位置，从这个位置开始到接下来第一个"null"字符为止的这个字符串,正是这个节的名字。  

.symtab ：符号表，记录的是函数和变量。我们在调试的时候经常说到的符号表就是指这个，把函数和变量统称为符号。链接的过程就是符号的管理，符号值就是地址。符号表中的符号类型分为，  
（1）定义在本目标文件的全局符号：可以被其他目标文件引用  
（2）在本目标引用的全局符号：也就是外部符号  
（3）段名：由编译器产生，它的值就是该段的起始地址  
（4）局部符号：静态变量  
（5）行号信息    
查看符号表 nm 目标文件

重定位表 ： 每一个需要重定位的代码段或数据段都有一个相应的重定位表.rel.data，.rel.text。  

### 3. 符号表
符号是链接的接口，链接的本质就是拼接各个目标文件的符号，每个目标文件都有自己的符号表，记录了目标文件中所用到的所有符号，每个定义的符号都有符号值，变量和函数的符号值就是他们的地址。elf文件中的符号表示一个单独的section，就是上面说的.symtab，符号表这个段里面存储的结构本身也是一个数组，数组下标为0固定表示一个未定义的无效符号，这个结构体的定义在include\uapi\linux\elf.h  
```C++
typedef struct elf32_sym{
    Elf32_Word  st_name;       //符号名，即该符号名在字符串表中的索引
    Elf32_Addr  st_value;      //符号值，对于变量和函数来说就是地址
    Elf32_Word  st_size;       //符号大小，0表示未知
    unsigned char st_info;     //符号类型和绑定信息
    unsigned char st_other;    //没用
    Elf32_Half  st_shndx;      //符号所在段索引
} Elf32_Sym;
```
符号名：这个无需多说，就是个index索引，符号名也是个字符串，保存在字符串表中。    
符号类型和绑定信息：低4位表示符号的类型，不知道为啥都说高28位表示符号绑定信息，是字节对齐了还是咋的，哪来的4个字节？  
符号绑定信息和符号类型，定义如下，  
```C++
#define STB_LOCAL  0  //局部符号
#define STB_GLOBAL 1  //全局符号
#define STB_WEAK   2  //弱引用
```
符号类型
```C++
#define STT_NOTYPE  0   //未知类型
#define STT_OBJECT  1   //数据对象，如数组、变量
#define STT_FUNC    2   //函数或可执行代码
#define STT_SECTION 3   //符号表示一个段，必须是STB_LOCAL
#define STT_FILE    4   //文件名，一般是目标文件的文件名
#define STT_COMMON  5
#define STT_TLS     6
```
符号所在段：如果符号定义在本目标文件中，那么就是这个符号所在段在段表中的下标。如果不是定义在本目标文件中或者部分符号则有些特殊，
```C++
#define SHN_UNDEF 0           //定义在其他文件中的符号
#define SHN_LORESERVE 0xff00
#define SHN_LOPROC  0xff00
#define SHN_HIPROC  0xff1f
#define SHN_LIVEPATCH 0xff20
#define SHN_ABS   0xfff1      //一个绝对的值，比如文件名的符号
#define SHN_COMMON  0xfff2    //“COMMON”块类型的符号，如未初始化的全局符号定义
#define SHN_HIRESERVE 0xffff  
```
符号值：简单说符号值就是地址，但是实际比较复杂：
（1）在目标文件中，如果符号不是COMMON块类型的，则st_value表示该符号在段中的偏移，即由st_shndx指定的段偏移的位置，这是目标文件中全局变量符号最常见的情况；  
（2）在目标文件中，符号是COMMON块类型的，表示该符号的对齐属性；  
（3）在可执行文件中，表示符号的虚拟地址。  


## 静态链接
链接简单来说就是将多个目标文件合并成一个可执行文件，采用的方式是相似段合并。链接过程也是在虚拟地址中分配空间的过程，链接一般分为两步：  
第一步 空间地址分配，链接器获取所有输入目标文件的段的长度，并进行合并，计算输出文件中各个段合并后的长度和位置，建立映射关系，将所有符号放到一个全局符号表中。  
第二步 符号解析和重定位，使用上一步收集到的信息，读取输入文件中段的数据和重定位信息，进行符号解析和重定位。  

### 空间地址分配
使用objdump -h 可以看到，对于目标文件，链接之前，目标文件中的所有段的VMA都是0，因为此时没有分配虚拟空间。而链接之后就会分配相应的地址，这里要注意，linux下elf可执行文件的默认分配地址有一个起始地址，64位和32位是不同的。
链接时进行相似段合并，简单说就是叠加，链接完成以后可执行文件的section的地址就是确定的。  
![静态链接](../../source/images/静态链接.png ':size=60%')  
在上面学习目标文件格式时，我们可以看到每一个符号相对于其段的起始地址的偏移都是知道的，链接器需要为每个符号加上偏移量得到正确的虚拟地址。  
前面符号表数据结构可以看到，符号值基本就是相对当前段的偏移地址，比如.text段，每个目标文件会进行.text合并，即使不同目标文件中的符号值相同也没关系，最后链接合并后的.text段的起始地址不同。

### 符号解析与重定位
目标文件中会将外部未定义的函数和变量地址标记为0xFFFFFFFC和0x00000000，这两个都是临时地址，在链接的时候，链接器会进行修正。  
链接器通过重定位表来获取需要重定位的信息，这就是前面看到的.rel.**段。对于可重定位的ELF文件来说，它必须包含重定位表，用来描述如何修改相应的节的内容。对于每个要被重定位的ELF节都有一个对应的重定位表。如果.text节需要被重定位，则会有一个相对应叫.rel.text的节保存了代码节的重定位表；如果.data节需要被重定位，则会有一个相对应的.rel.tdata的节保存了数据节的重定位表。  
重定位表也是一个结构体数组，这个结构体中的值在目标文件和共享文件中的含义不太一样。  

具体来说，链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。
然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，链接器会从所有输出目标文件的符号表组成的全局符号表中进行查找，如果未找到就会报未定义错误。  

另一方面，对全局符号的解析，经常会面临多个目标文件可能会定义相同名字的全局符号。这种情况下，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义。
Linux编译系统采用如下的方法解决多重定义的全局符号解析：

在编译时，编译器想汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中。

根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名：

> 规则1：不允许有多个同名的强符号。      
> 规则2：如果有一个强符号和多个弱符号同名，则选择强符号。      
> 规则3：如果有多个弱符号同名，则从这些弱符号中任意选择一个。      

另一方面，由于允许一个符号定义在多个文件中，所以可能会导致一个问题：如果一个弱符号定义在多个目标文件中，而它们的类型不同，怎么办？这种情况主要有三种：

> 情况1：两个或两个以上的强符号类型不一致。     
> 情况2：有一个强符号，其他都是弱符号，出现类型不一致。     
> 情况3：两个或两个以上弱符号类型不一致。    

其中，情况1由于多个强符号定义本身就是非法的，所以链接器就会报错。对于后两种情况，编译器和链接器采用一种叫 COMMON块（Common Block ） 的机制来处理。其过程如下：
首先，编译器将未初始化的全局变量定义为弱符号处理，标记为COMMON类型，目标文件中COMMON类型不会在bss段分配空间。对于情况3，最终链接时按照COMMON类型规则选择最大的类型。对于情况2，最终输出结果中的符号所占空间与强符号相同，如果链接过程中有弱符号大于强符号，链接器会发出警告。

### C++链接相关问题
C++在编译时可能会产生很多重复代码，比如模板、内联函数和虚函数表。gcc的做法是，所有的模板实例化代码都单独放到一个段，比如.temp.add<int>, .temp.add<float>，当别的目标文件中也生成了同样的段时，链接器就可以合并它们。在gcc里面就是.gnu.linkonce.name段。虚函数表也是如此，因为多个编译单元都会生成虚函数表，也需要消除。
C++中还有两个特殊的段，.init和.fini段，C++的全局对象的构造和析构函数就是借由此实现的。前者会在main函数之前被调用，后者在main函数正常退出后调用。
